# -*- coding: utf-8-unix -*-

# Copyright (c) 2025 Daishi Mori (mori0091)
#
# This software is released under the MIT License.
# See https://github.com/mori0091/ase2msx

def toidentifier(s):
    import re
    return re.sub(r'\W', '_', s) # TODO What should we do if it starts with digits[0-9]?

def tofile(a_ase, meta, img):
    import os
    import numpy as np
    from . import cel

    name, ext = os.path.splitext(a_ase)

    height, width = img.shape
    assert meta['size']['w'] == width and meta['size']['h'] == height, \
        f"Size mismatch {meta['size']} != {(width, height)}"

    file_header = f"// Code generated by ase2msx {a_ase}; DO NOT EDIT.\n"

    # {name}.sm2 - List of cel images (sprite pattern table, color table, and attribute table)
    with open(f'{name}.sm2', mode='wb') as cels_bin:
        np.set_printoptions(threshold=np.inf, linewidth=np.inf)
        for i, xywh in enumerate(meta['cels']):
            x, y, w, h = xywh.values()
            a_cel = img[y:y+h, x:x+w]
            c = cel.encode(a_cel)
            cel.tofile(cels_bin, c)
            print(f"# cel #{i}: depth={c['depth']}")

            # np.set_printoptions(formatter={'int': '{:X}'.format})
            # print(f'# cel #{i}')
            # print(a_cel)
            # print()

            # np.set_printoptions(formatter={'int': '{:02X}'.format})
            # for key, val in c.items():
            #     print(f'#{key}:')
            #     print(val)
            #     print()

    ident = toidentifier(name)
    # {name}.h - C header file
    with open(f'{name}.h', mode='w', encoding='utf-8') as f:
        NAME_H_ = f'{ident.upper()}_H_'
        tags = '\n'.join([f'extern const sm2_FrameTag {ident}_tag_{toidentifier(tag["name"])};' for tag in meta['frameTags']])
        f.write(file_header)
        f.write(f'#ifndef {NAME_H_}\n'
                f'#define {NAME_H_}\n'
                f'\n'
                f'#include "sm2.h"\n'
                f'#include "sm2_bmem.h"\n'
                f'\n'
                f'extern const sm2_SpriteSheet {ident};\n'
                f'{tags}\n'
                f'\n'
                f'void {ident}_init(void);\n'
                f'\n'
                f'#endif // {NAME_H_}\n'
                )

    # {name}.c - C source file
    with open(f'{name}.c', mode='w', encoding='utf-8') as f:
        f.write(file_header)
        f.write(f'#include "{name}.h"\n'
                f'\n'
                f'#define LEN(a) (sizeof(a)/sizeof(a[0]))\n'
                f'#define CELS_MAX ({len(meta['cels'])})\n'
                f'\n'
                f'static sm2_Cel cels[CELS_MAX];\n'
                )
        for i, frame in enumerate(meta['frames']):
            f.write(f'static const uint8_t frame_{i}_cel_ids[] = ''{')
            for j in frame['cels']:
                f.write(f'{j},')
            f.write('};\n')
        f.write(f'static const sm2_Frame frames[] = ''{\n')
        for i, frame in enumerate(meta['frames']):
            f.write(f'  {{.duration = {frame['duration']}, .cel_ids = SM2_SLICE(frame_{i}_cel_ids), }},\n')
        f.write('};\n')
        f.write('\n')
        f.write(f'const sm2_SpriteSheet {ident} = ''{\n'
                '  .frames = SM2_SLICE(frames),\n'
                '  .cels = SM2_SLICE(cels),\n'
                '};\n')
        for tag in meta['frameTags']:
            f.write(f'const sm2_FrameTag {ident}_tag_{toidentifier(tag["name"])} = ''{')
            f.write(f'.from = {tag["from"]}, .to = {tag["to"]}, .direction = SM2_{tag["direction"].upper()}, ' )
            if "repeats" in tag:
                f.write(f'.repeats = {tag["repeats"]}')
            f.write('};\n')
        f.write('\n'
                f'void {ident}_init(void)''{\n'
                f'  sm2_load_cel_resource("{name}.sm2", cels, LEN(cels));\n'
                '}\n'
                )

def convert(a_ase, a_json, a_png):
    import os
    from PIL import Image
    import numpy as np
    from . import sheet_json

    meta = sheet_json.load(a_json)
    sheet_json.dump(meta)

    with Image.open(a_png) as im:
        print(im.format, im.size, im.mode)
        assert im.width % 16 == 0 and im.height % 16 == 0, \
            'Width and height of the image must be multiple of 16'
        assert im.mode == 'P' and len(im.getcolors()) <= 16, \
            'The image must be IndexColor up to 16 colors'

        color_codes = [color for num,color in im.getcolors()]
        if np.any(np.array(color_codes) >= 16):
            print()
            print('Warning: Detected color code exceeds 15.')
            print('  The color code will be treated as mod 16.')
            print('  (e.g. color code #16 becomes #0).')
            print()
            print(f' Detected color codes: {color_codes}')
            print()

        tofile(a_ase, meta, np.array(im))

        palette = im.getpalette()
        palette = np.array(palette).reshape((len(palette)//3,3))

        np.set_printoptions(formatter={'int': '{:3d}'.format})
        print('# color palette [FYI]')
        print(palette)
        print()
